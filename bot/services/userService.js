const { Op } = require('sequelize');

class UserService {
  constructor(models) {
    this.models = models;
  }

  async findOrCreate(telegramId, username) {
    try {
      const [user, created] = await this.models.User.findOrCreate({
        where: { telegramId },
        defaults: {
          username,
          level: 1,
          experience: 0,
          gold: 5000,
          gems: 500,
          lastBattleAt: null
        }
      });

      if (created) {
        console.log(`‚úÖ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${username} (${telegramId})`);
        await this.createStarterHeroes(user.id);
        await this.createStarterTeam(user.id);
      }

      return user;
    } catch (error) {
      console.error('UserService.findOrCreate error:', error);
      throw error;
    }
  }

  async findByTelegramId(telegramId) {
    try {
      const user = await this.models.User.findOne({
        where: { telegramId },
        include: [
          { model: this.models.Hero },
          { 
            model: this.models.Team, 
            include: [{ model: this.models.Hero }] 
          }
        ]
      });

      if (!user) {
        throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
      }

      return user;
    } catch (error) {
      console.error('UserService.findByTelegramId error:', error);
      throw error;
    }
  }

  async findById(userId) {
    try {
      const user = await this.models.User.findByPk(userId, {
        include: [
          { model: this.models.Hero },
          { 
            model: this.models.Team, 
            include: [{ model: this.models.Hero }] 
          }
        ]
      });

      if (!user) {
        throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
      }

      return user;
    } catch (error) {
      console.error('UserService.findById error:', error);
      throw error;
    }
  }

  async findRandomOpponent(currentUserId) {
    try {
      const opponent = await this.models.User.findOne({
        where: {
          id: { [Op.ne]: currentUserId }
        },
        include: [{
          model: this.models.Team,
          where: { isActive: true },
          include: [{
            model: this.models.Hero,
            where: { isActive: true },
            required: true
          }]
        }],
        order: this.models.sequelize.random()
      });

      if (!opponent) {
        return await this.createBotUser();
      }

      return opponent;
    } catch (error) {
      console.error('UserService.findRandomOpponent error:', error);
      return await this.createBotUser();
    }
  }

  async createBotUser() {
    try {
      const botUser = await this.models.User.create({
        telegramId: Math.floor(Math.random() * 1000000) * -1,
        username: '–ë–æ—Ç-–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫',
        level: 1,
        experience: 0,
        gold: 0,
        gems: 0
      });

      await this.createBotTeam(botUser.id);

      return await this.findById(botUser.id);
    } catch (error) {
      console.error('UserService.createBotUser error:', error);
      throw error;
    }
  }

  async createBotTeam(userId) {
    try {
      const botTeam = await this.models.Team.create({
        name: '–ö–æ–º–∞–Ω–¥–∞ –±–æ—Ç–∞',
        isActive: true,
        userId: userId
      });

      const botHeroes = [
        {
          name: '–í–æ–∏–Ω –±–æ—Ç–∞',
          level: 1,
          health: 100,
          attack: 15,
          defense: 8,
          speed: 5,
          criticalChance: 0.1,
          criticalDamage: 1.5,
          heroClass: 'warrior',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–õ—É—á–Ω–∏–∫ –±–æ—Ç–∞',
          level: 1,
          health: 80,
          attack: 20,
          defense: 5,
          speed: 8,
          criticalChance: 0.15,
          criticalDamage: 2.0,
          heroClass: 'archer',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ú–∞–≥ –±–æ—Ç–∞',
          level: 1,
          health: 70,
          attack: 25,
          defense: 3,
          speed: 6,
          criticalChance: 0.12,
          criticalDamage: 2.2,
          heroClass: 'mage',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–¢–∞–Ω–∫ –±–æ—Ç–∞',
          level: 1,
          health: 120,
          attack: 10,
          defense: 12,
          speed: 3,
          criticalChance: 0.05,
          criticalDamage: 1.3,
          heroClass: 'tank',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–õ–µ–∫–∞—Ä—å –±–æ—Ç–∞',
          level: 1,
          health: 90,
          attack: 12,
          defense: 6,
          speed: 7,
          criticalChance: 0.08,
          criticalDamage: 1.8,
          heroClass: 'healer',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ê—Å—Å–∞—Å—Å–∏–Ω –±–æ—Ç–∞',
          level: 1,
          health: 75,
          attack: 22,
          defense: 4,
          speed: 9,
          criticalChance: 0.18,
          criticalDamage: 2.5,
          heroClass: 'assassin',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –±–æ—Ç–∞',
          level: 1,
          health: 85,
          attack: 8,
          defense: 7,
          speed: 6,
          criticalChance: 0.06,
          criticalDamage: 1.6,
          heroClass: 'support',
          rarity: 'common',
          userId: userId
        }
      ];

      // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã—Ö 5 –≥–µ—Ä–æ–µ–≤ –∏–∑ 7 –≤–æ–∑–º–æ–∂–Ω—ã—Ö –¥–ª—è –±–æ—Ç–∞
      const shuffledHeroes = botHeroes.sort(() => 0.5 - Math.random());
      const selectedHeroes = shuffledHeroes.slice(0, 5);

      const createdHeroes = await this.models.Hero.bulkCreate(selectedHeroes);

      for (let i = 0; i < createdHeroes.length; i++) {
        await this.models.TeamHero.create({
          teamId: botTeam.id,
          heroId: createdHeroes[i].id,
          position: i + 1
        });
      }

      return botTeam;
    } catch (error) {
      console.error('UserService.createBotTeam error:', error);
      throw error;
    }
  }

  async createStarterHeroes(userId) {
    try {
      const starterHeroes = [
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –≤–æ–∏–Ω',
          level: 1,
          health: 100,
          attack: 15,
          defense: 8,
          speed: 5,
          criticalChance: 0.1,
          criticalDamage: 1.5,
          heroClass: 'warrior',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –ª—É—á–Ω–∏–∫',
          level: 1,
          health: 80,
          attack: 20,
          defense: 5,
          speed: 8,
          criticalChance: 0.15,
          criticalDamage: 2.0,
          heroClass: 'archer',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –º–∞–≥',
          level: 1,
          health: 70,
          attack: 25,
          defense: 3,
          speed: 6,
          criticalChance: 0.12,
          criticalDamage: 2.2,
          heroClass: 'mage',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π —Ç–∞–Ω–∫',
          level: 1,
          health: 120,
          attack: 10,
          defense: 12,
          speed: 3,
          criticalChance: 0.05,
          criticalDamage: 1.3,
          heroClass: 'tank',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –ª–µ–∫–∞—Ä—å',
          level: 1,
          health: 90,
          attack: 12,
          defense: 6,
          speed: 7,
          criticalChance: 0.08,
          criticalDamage: 1.8,
          heroClass: 'healer',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –∞—Å—Å–∞—Å—Å–∏–Ω',
          level: 1,
          health: 75,
          attack: 22,
          defense: 4,
          speed: 9,
          criticalChance: 0.18,
          criticalDamage: 2.5,
          heroClass: 'assassin',
          rarity: 'common',
          userId: userId
        },
        {
          name: '–ù–∞—á–∞–ª—å–Ω—ã–π –ø–æ–¥–¥–µ—Ä–∂–∫–∞',
          level: 1,
          health: 85,
          attack: 8,
          defense: 7,
          speed: 6,
          criticalChance: 0.06,
          criticalDamage: 1.6,
          heroClass: 'support',
          rarity: 'common',
          userId: userId
        }
      ];

      // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã—Ö 5 –≥–µ—Ä–æ–µ–≤ –∏–∑ 7 –≤–æ–∑–º–æ–∂–Ω—ã—Ö –¥–ª—è –∏–≥—Ä–æ–∫–∞
      const shuffledHeroes = starterHeroes.sort(() => 0.5 - Math.random());
      const selectedHeroes = shuffledHeroes.slice(0, 5);

      await this.models.Hero.bulkCreate(selectedHeroes);
      console.log(`‚úÖ –°–æ–∑–¥–∞–Ω—ã 5 —Å–ª—É—á–∞–π–Ω—ã—Ö —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö –≥–µ—Ä–æ–µ–≤ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
      
      // –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∫–∏–µ –≥–µ—Ä–æ–∏ –±—ã–ª–∏ —Å–æ–∑–¥–∞–Ω—ã
      const createdHeroes = await this.models.Hero.findAll({
        where: { userId },
        attributes: ['name', 'heroClass']
      });
      console.log(`üéØ –°–æ–∑–¥–∞–Ω–Ω—ã–µ –≥–µ—Ä–æ–∏:`, createdHeroes.map(h => `${h.name} (${h.heroClass})`));

    } catch (error) {
      console.error('UserService.createStarterHeroes error:', error);
      throw error;
    }
  }

  async createStarterTeam(userId) {
    try {
      const team = await this.models.Team.create({
        name: '–°—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞',
        isActive: true,
        userId: userId
      });

      const heroes = await this.models.Hero.findAll({
        where: { userId },
        limit: 5
      });

      for (let i = 0; i < heroes.length; i++) {
        await this.models.TeamHero.create({
          teamId: team.id,
          heroId: heroes[i].id,
          position: i + 1
        });
      }

      console.log(`‚úÖ –°–æ–∑–¥–∞–Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}`);
      return team;
    } catch (error) {
      console.error('UserService.createStarterTeam error:', error);
      throw error;
    }
  }

  async updateUserResources(userId, resources) {
    try {
      const user = await this.findById(userId);
      
      const updateData = {};
      if (resources.gold !== undefined) {
        updateData.gold = user.gold + resources.gold;
      }
      if (resources.gems !== undefined) {
        updateData.gems = user.gems + resources.gems;
      }
      if (resources.experience !== undefined) {
        updateData.experience = user.experience + resources.experience;
        
        const requiredExp = user.level * 100;
        if (updateData.experience >= requiredExp) {
          updateData.level = user.level + 1;
          updateData.experience = updateData.experience - requiredExp;
        }
      }

      await user.update(updateData);
      return user;
    } catch (error) {
      console.error('UserService.updateUserResources error:', error);
      throw error;
    }
  }

  async getUserStats(userId) {
    try {
      const user = await this.findById(userId);
      const heroesCount = await this.models.Hero.count({ where: { userId } });
      const battlesCount = await this.models.Battle.count({
        where: {
          [Op.or]: [
            { player1Id: userId },
            { player2Id: userId }
          ],
          status: 'completed'
        }
      });
      const winsCount = await this.models.Battle.count({
        where: { winnerId: userId }
      });

      return {
        user,
        heroesCount,
        battlesCount,
        winsCount,
        winRate: battlesCount > 0 ? (winsCount / battlesCount * 100).toFixed(1) : 0
      };
    } catch (error) {
      console.error('UserService.getUserStats error:', error);
      throw error;
    }
  }

  async getTeamManagementInfo(telegramId) {
    try {
      const user = await this.findByTelegramId(telegramId);
      const allHeroes = await this.models.Hero.findAll({
        where: { userId: user.id },
        order: [['level', 'DESC']]
      });

      const activeTeam = await this.models.Team.findOne({
        where: { userId: user.id, isActive: true },
        include: [{
          model: this.models.Hero,
          through: { attributes: ['position'] }
        }]
      });

      const teamHeroes = activeTeam ? 
        activeTeam.Heroes.sort((a, b) => a.TeamHero.position - b.TeamHero.position) : 
        [];

      return {
        user,
        allHeroes,
        activeTeam,
        teamHeroes,
        availableSlots: 5 - teamHeroes.length,
        hasFullTeam: teamHeroes.length === 5
      };
    } catch (error) {
      console.error('UserService.getTeamManagementInfo error:', error);
      throw error;
    }
  }

  async addHeroToTeam(telegramId, heroId, position) {
    try {
      const user = await this.findByTelegramId(telegramId);
      const team = await this.models.Team.findOne({
        where: { userId: user.id, isActive: true }
      });

      if (!team) {
        throw new Error('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–∞–Ω–¥—É —Å –ø–æ–º–æ—â—å—é /create_team');
      }

      const hero = await this.models.Hero.findOne({
        where: { id: heroId, userId: user.id }
      });

      if (!hero) {
        throw new Error('–ì–µ—Ä–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º');
      }

      const existingInTeam = await this.models.TeamHero.findOne({
        where: { teamId: team.id, heroId }
      });

      if (existingInTeam) {
        throw new Error('–≠—Ç–æ—Ç –≥–µ—Ä–æ–π —É–∂–µ –≤ –∫–æ–º–∞–Ω–¥–µ');
      }

      if (!position) {
        const occupiedPositions = await this.models.TeamHero.findAll({
          where: { teamId: team.id },
          attributes: ['position']
        });
        
        const occupied = occupiedPositions.map(p => p.position);
        position = [1, 2, 3, 4, 5].find(p => !occupied.includes(p));
        
        if (!position) {
          throw new Error('–í –∫–æ–º–∞–Ω–¥–µ –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤');
        }
      }

      if (position < 1 || position > 5) {
        throw new Error('–ü–æ–∑–∏—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 1 –¥–æ 5');
      }

      const positionOccupied = await this.models.TeamHero.findOne({
        where: { teamId: team.id, position }
      });

      if (positionOccupied) {
        throw new Error(`–ü–æ–∑–∏—Ü–∏—è ${position} —É–∂–µ –∑–∞–Ω—è—Ç–∞`);
      }

      await this.models.TeamHero.create({
        teamId: team.id,
        heroId: heroId,
        position: position
      });

      return { success: true, position };
    } catch (error) {
      console.error('UserService.addHeroToTeam error:', error);
      throw error;
    }
  }

  async removeHeroFromTeam(telegramId, heroId) {
    try {
      const user = await this.findByTelegramId(telegramId);
      const team = await this.models.Team.findOne({
        where: { userId: user.id, isActive: true }
      });

      if (!team) {
        throw new Error('–ê–∫—Ç–∏–≤–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
      }

      const result = await this.models.TeamHero.destroy({
        where: { teamId: team.id, heroId }
      });

      if (result === 0) {
        throw new Error('–ì–µ—Ä–æ–π –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ–º–∞–Ω–¥–µ');
      }

      return { success: true };
    } catch (error) {
      console.error('UserService.removeHeroFromTeam error:', error);
      throw error;
    }
  }

  // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –≥–µ—Ä–æ–µ–≤ –ø–æ –∫–ª–∞—Å—Å–∞–º
  sortHeroesByClass(heroes) {
    const classOrder = {
      'tank': 1,
      'warrior': 2,
      'archer': 3,
      'mage': 4,
      'assassin': 5,
      'healer': 6,
      'support': 7
    };

    return heroes.sort((a, b) => {
      return classOrder[a.heroClass] - classOrder[b.heroClass];
    });
  }

  // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–ª–∞—Å—Å–∞—Ö –≥–µ—Ä–æ–µ–≤
  getHeroClassesInfo() {
    return {
      'warrior': { name: '–í–æ–∏–Ω', emoji: '‚öîÔ∏è', description: '–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–æ–µ—Ü' },
      'archer': { name: '–õ—É—á–Ω–∏–∫', emoji: 'üèπ', description: '–í—ã—Å–æ–∫–∏–π —É—Ä–æ–Ω, –Ω–∏–∑–∫–∞—è –∑–∞—â–∏—Ç–∞' },
      'mage': { name: '–ú–∞–≥', emoji: 'üîÆ', description: '–ú–æ—â–Ω—ã–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è' },
      'tank': { name: '–¢–∞–Ω–∫', emoji: 'üõ°Ô∏è', description: '–í—ã—Å–æ–∫–∞—è –∑–∞—â–∏—Ç–∞, –Ω–∏–∑–∫–∏–π —É—Ä–æ–Ω' },
      'healer': { name: '–õ–µ–∫–∞—Ä—å', emoji: 'üíä', description: '–õ–µ—á–µ–Ω–∏–µ —Å–æ—é–∑–Ω–∏–∫–æ–≤' },
      'assassin': { name: '–ê—Å—Å–∞—Å—Å–∏–Ω', emoji: 'üó°Ô∏è', description: '–í—ã—Å–æ–∫–∏–π –∫—Ä–∏—Ç. —É—Ä–æ–Ω, –Ω–∏–∑–∫–æ–µ –∑–¥–æ—Ä–æ–≤—å–µ' },
      'support': { name: '–ü–æ–¥–¥–µ—Ä–∂–∫–∞', emoji: 'üéØ', description: '–£—Å–∏–ª–µ–Ω–∏–µ —Å–æ—é–∑–Ω–∏–∫–æ–≤' }
    };
  }
  async getTeamForWebApp(telegramId) {
   try {
     const user = await this.findByTelegramId(telegramId);
     const activeTeam = await this.models.Team.findOne({
       where: { userId: user.id, isActive: true },
       include: [{
         model: this.models.Hero,
         through: { attributes: ['position'] }
       }]
     });

     const allHeroes = await this.models.Hero.findAll({
       where: { userId: user.id, isActive: true },
       order: [['level', 'DESC']]
     });

     const teamHeroes = activeTeam ? 
       activeTeam.Heroes.sort((a, b) => a.TeamHero.position - b.TeamHero.position) : 
       [];

     return {
       user: {
         id: user.id,
         username: user.username,
         level: user.level,
         gold: user.gold,
         gems: user.gems
       },
       team: activeTeam ? {
         id: activeTeam.id,
         name: activeTeam.name,
         heroes: teamHeroes.map(hero => ({
           id: hero.id,
           name: hero.name,
           level: hero.level,
           health: hero.health,
           attack: hero.attack,
           defense: hero.defense,
           speed: hero.speed,
           criticalChance: hero.criticalChance,
           criticalDamage: hero.criticalDamage,
           heroClass: hero.heroClass,
           rarity: hero.rarity,
           position: hero.TeamHero.position,
           emoji: this.getHeroEmoji(hero.heroClass)
         }))
       } : null,
       availableHeroes: allHeroes
         .filter(hero => !teamHeroes.some(th => th.id === hero.id))
         .map(hero => ({
           id: hero.id,
           name: hero.name,
           level: hero.level,
           health: hero.health,
           attack: hero.attack,
           defense: hero.defense,
           speed: hero.speed,
           criticalChance: hero.criticalChance,
           criticalDamage: hero.criticalDamage,
           heroClass: hero.heroClass,
           rarity: hero.rarity,
           emoji: this.getHeroEmoji(hero.heroClass)
         })),
       maxTeamSize: 5
     };
   } catch (error) {
     console.error('UserService.getTeamForWebApp error:', error);
     throw error;
   }
 }

 // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã –∏–∑ Web App
 async updateTeamFromWebApp(telegramId, heroIds) {
   try {
     const user = await this.findByTelegramId(telegramId);
     
     // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –≥–µ—Ä–æ–∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
     const userHeroes = await this.models.Hero.findAll({
       where: { 
         id: { [Op.in]: heroIds },
         userId: user.id 
       }
     });

     if (userHeroes.length !== heroIds.length) {
       throw new Error('–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≥–µ—Ä–æ–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –≤–∞–º');
     }

     // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
     if (new Set(heroIds).size !== heroIds.length) {
       throw new Error('–í –∫–æ–º–∞–Ω–¥–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –≥–µ—Ä–æ–µ–≤');
     }

     if (heroIds.length > 5) {
       throw new Error('–ú–∞–∫—Å–∏–º—É–º 5 –≥–µ—Ä–æ–µ–≤ –≤ –∫–æ–º–∞–Ω–¥–µ');
     }

     // –ù–∞—Ö–æ–¥–∏–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –∫–æ–º–∞–Ω–¥—É
     let team = await this.models.Team.findOne({
       where: { userId: user.id, isActive: true }
     });

     if (!team) {
       team = await this.models.Team.create({
         name: `–ö–æ–º–∞–Ω–¥–∞ ${user.username}`,
         isActive: true,
         userId: user.id
       });
     }

     // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã—Ö –≥–µ—Ä–æ–µ–≤ –∏–∑ –∫–æ–º–∞–Ω–¥—ã
     await this.models.TeamHero.destroy({
       where: { teamId: team.id }
     });

     // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã—Ö –≥–µ—Ä–æ–µ–≤
     for (let i = 0; i < heroIds.length; i++) {
       await this.models.TeamHero.create({
         teamId: team.id,
         heroId: heroIds[i],
         position: i + 1
       });
     }

     return { success: true, teamSize: heroIds.length };
   } catch (error) {
     console.error('UserService.updateTeamFromWebApp error:', error);
     throw error;
   }
 }

 getHeroEmoji(heroClass) {
   const emojis = {
     'warrior': '‚öîÔ∏è',
     'archer': 'üèπ',
     'mage': 'üîÆ',
     'tank': 'üõ°Ô∏è',
     'healer': 'üíä',
     'assassin': 'üó°Ô∏è',
     'support': 'üéØ'
   };
   return emojis[heroClass] || 'üë§';
 }
}

module.exports = UserService;
